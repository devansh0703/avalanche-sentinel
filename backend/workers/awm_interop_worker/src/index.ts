import { createClient } from 'redis';
import solc from 'solc';

// --- Type Definitions (Unchanged) ---
interface AnalysisJob {
    job_id: string;
    source_code: string;
}
interface AWM_Issue {
    issue_type: string;
    description: string;
    recommendation: string;
}
interface AnalysisResult {
    job_id: string;
    worker_name: string;
    output: AWM_Issue[];
}

// --- V3: Advanced AST Visitor with Parent Tracking ---
function visit(node: any, visitor: { [nodeType: string]: (node: any, parent: any) => void }, parent: any = null) {
    if (!node || typeof node !== 'object') return;
    if (node.nodeType && visitor[node.nodeType]) {
        visitor[node.nodeType](node, parent);
    }
    for (const key in node) {
        if (node.hasOwnProperty(key)) {
            const child = node[key];
            if (child instanceof Array) {
                for (const item of child) visit(item, visitor, node); // Pass current node as parent
            } else if (child) {
                visit(child, visitor, node); // Pass current node as parent
            }
        }
    }
}

// --- Main Worker Logic (Unchanged) ---
async function main() {
    console.log('Starting AWM Interoperability Worker [V3 DEFINITIVE]...');
    const redisClient = createClient();
    await redisClient.connect();
    console.log('Successfully connected to Redis.');

    const channel = 'awm_interop_jobs';
    console.log(`Listening for jobs on channel: '${channel}'`);

    while (true) {
        try {
            const jobData = await redisClient.blPop(channel, 0);
            if (jobData) {
                console.log('\nReceived new job.');
                const job: AnalysisJob = JSON.parse(jobData.element);
                console.log(`Processing Job ID: ${job.job_id}`);
                const result = analyzeAWM_V3(job);
                await publishResult(redisClient, result);
            }
        } catch (error) {
            console.error('Error processing job:', error);
        }
    }
}

// --- V3: Definitive Analysis Function ---
function analyzeAWM_V3(job: AnalysisJob): AnalysisResult {
    let issues: AWM_Issue[] = [];
    const fileName = 'contract.sol';
    const interfaceFileName = 'IAvalancheWarpMessenger.sol';

    const input = {
        language: 'Solidity',
        sources: {
            [fileName]: { content: job.source_code },
            [interfaceFileName]: { content: `pragma solidity ^0.8.10; interface IAvalancheWarpMessenger { function send(bytes calldata message) external returns (bytes32 messageId); }` }
        },
        settings: { outputSelection: { [fileName]: { '': ['ast'] } } }
    };

    try {
        const output = JSON.parse(solc.compile(JSON.stringify(input)));
        
        if (output.errors) {
            const compilationErrors = output.errors.filter((e: any) => e.severity === 'error');
            if (compilationErrors.length > 0) {
                throw new Error(compilationErrors.map((e: any) => e.formattedMessage).join('\n'));
            }
        }

        const ast = output.sources[fileName].ast;
        if (!ast) { throw new Error("AST was not generated by the compiler."); }

        let receiveFunctionNode: any | null = null;
        let hasReplayProtectionMapping = false;
        let sendInTryCatch = false;
        let totalSendCalls = 0;
        let hasStateChangingSend = false;
        let hasFailureHandler = false;

        // --- DEFINITIVE V3 LOGIC ---
        // First, build a map of all nodes and their parents for easy lookup.
        const parentMap = new Map<any, any>();
        visit(ast, {
            '*': (node, parent) => {
                if(parent) parentMap.set(node, parent);
            }
        });
        
        visit(ast, {
            FunctionDefinition: (node) => {
                if (node.name === 'receive') receiveFunctionNode = node;
                if (node.name && (node.name.toLowerCase().includes('fail') || node.name.toLowerCase().includes('rollback'))) hasFailureHandler = true;
            },
            VariableDeclaration: (node) => {
                if (node.typeName && node.typeName.nodeType === 'Mapping') {
                    if (node.typeName.keyType.name === 'bytes32' && node.typeName.valueType.name === 'bool') hasReplayProtectionMapping = true;
                }
            },
            FunctionCall: (node, parent) => {
                if (node.expression.nodeType === 'MemberAccess' && node.expression.memberName === 'send') {
                    totalSendCalls++;
                    
                    // Walk up the parent tree to find the containing function definition
                    let current = node;
                    while (current && current.nodeType !== 'FunctionDefinition') {
                        current = parentMap.get(current);
                    }
                    
                    if (current && current.nodeType === 'FunctionDefinition') {
                        // A function is state-changing if its stateMutability is not 'view' or 'pure'.
                        if (current.stateMutability !== 'view' && current.stateMutability !== 'pure') {
                            hasStateChangingSend = true;
                        }
                    }
                    
                    // Also check if this specific call is inside a TryStatement
                    let parentCursor = parent;
                     while(parentCursor) {
                        if (parentCursor.nodeType === 'TryStatement') {
                            sendInTryCatch = true;
                            break;
                        }
                        parentCursor = parentMap.get(parentCursor);
                    }
                }
            }
        });
        // --- END OF DEFINITIVE V3 LOGIC ---


        if (receiveFunctionNode) {
            const body = JSON.stringify(receiveFunctionNode.body);
            if (!body.includes('sourceChainId')) issues.push({ issue_type: "Critical Security Risk", description: "The `receive` function does not validate `warpMessage.sourceChainId`.", recommendation: "ALWAYS verify the source chain ID to prevent messages from unauthorized Subnets." });
            if (!body.includes('sender')) issues.push({ issue_type: "High Security Risk", description: "The `receive` function does not validate `warpMessage.sender`.", recommendation: "ALWAYS verify the sender address to ensure the message is from a trusted source." });
            if (!hasReplayProtectionMapping || !body.includes('executedMessages')) issues.push({ issue_type: "Critical Security Risk", description: "No replay protection mechanism was found or used in the `receive` function.", recommendation: "To prevent replay attacks, use a mapping to track executed message IDs." });
            
            const awmPrecompileAddress = "0x0000000000000000000000000000000000000000";
            if (!body.includes('msg.sender') || !body.includes(awmPrecompileAddress)) {
                 issues.push({ issue_type: "Critical Security Risk", description: "The `receive` function does not validate that `msg.sender` is the official AWM Precompile address.", recommendation: "A valid Warp message can be relayed by anyone. To prevent spoofing and ensure authenticity, add `require(msg.sender == AWM_PRECOMPILE_ADDRESS, \"Unauthorized relayer\");` to your `receive` function." });
            }
        } else {
            if (job.source_code.includes("IAvalancheWarpMessenger")) issues.push({ issue_type: "Missing `receive` Function", description: "The contract imports the AWM interface but is missing the `receive` function.", recommendation: "Implement `receive(bytes calldata signedMessage)` to process Warp messages." });
        }

        if (totalSendCalls > 0 && !sendInTryCatch) issues.push({ issue_type: "Robustness Issue", description: "A call to the AWM `.send()` function was detected outside of a `try/catch` block.", recommendation: "Wrap your `.send()` call in a `try/catch` block to handle potential failures gracefully." });
        
        if (hasStateChangingSend && !hasFailureHandler) {
             issues.push({ issue_type: "State Desynchronization Hazard", description: "The contract sends state-changing messages but appears to lack a failure handling or rollback mechanism.", recommendation: "For critical cross-chain updates, implement a mechanism to handle message delivery failures. This could be a `handleSendFailure(bytes32 messageId)` function that can be called by a trusted relayer or a timeout-based rollback." });
        }
        
        console.log(`V3 analysis complete. Found ${issues.length} AWM issues for Job ID: ${job.job_id}`);
        
        const uniqueIssues = issues.filter((issue, index, self) => index === self.findIndex((t) => (t.description === issue.description)));
        return { job_id: job.job_id, worker_name: "AWM_InteropWorkerV3", output: uniqueIssues };

    } catch (error: any) {
        return { job_id: job.job_id, worker_name: "AWM_InteropWorkerV3", output: [{ issue_type: "Analysis Error", description: error.message || "The contract could not be analyzed.", recommendation: "Ensure the contract is compilable." }]};
    }
}

async function publishResult(client: any, result: AnalysisResult) {
    const channel = 'sentinel_results';
    const resultJson = JSON.stringify(result);
    await client.rPush(channel, resultJson);
    console.log(`Published V3 result for Job ID: ${result.job_id}`);
}
main().catch(console.error);
