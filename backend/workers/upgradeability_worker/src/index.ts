import { createClient } from 'redis';
import solc from 'solc';

// --- Type Definitions (Unchanged) ---
interface AnalysisJob {
    job_id: string;
    source_code: string;
}
interface UpgradeIssue {
    issue_type: string;
    description: string;
    recommendation: string;
}
interface AnalysisResult {
    job_id: string;
    worker_name: string;
    output: UpgradeIssue[];
}

// --- Robust AST Visitor (Unchanged) ---
function visit(node: any, visitor: { [nodeType: string]: (node: any) => void }) {
    if (!node || typeof node !== 'object') return;
    if (node.nodeType && visitor[node.nodeType]) visitor[node.nodeType](node);
    for (const key in node) {
        if (node.hasOwnProperty(key)) {
            const child = node[key];
            if (child instanceof Array) {
                for (const item of child) visit(item, visitor);
            } else if (child) {
                visit(child, visitor);
            }
        }
    }
}

// --- Main Worker Logic (Unchanged) ---
async function main() {
    console.log('Starting Upgradeability & Governance Worker [V3 DEFINITIVE]...');
    const redisClient = createClient();
    await redisClient.connect();
    console.log('Successfully connected to Redis.');

    const channel = 'upgradeability_jobs';
    console.log(`Listening for jobs on channel: '${channel}'`);

    while (true) {
        try {
            const jobData = await redisClient.blPop(channel, 0);
            if (jobData) {
                const job: AnalysisJob = JSON.parse(jobData.element);
                console.log(`\nProcessing Job ID: ${job.job_id}`);
                const result = analyzeUpgradeabilityV3(job);
                await publishResult(redisClient, result);
            }
        } catch (error) {
            console.error('Error processing job:', error);
        }
    }
}

// --- V3: Definitive, Corrected Analysis Function ---
function analyzeUpgradeabilityV3(job: AnalysisJob): AnalysisResult {
    let issues: UpgradeIssue[] = [];
    const fileName = 'contract.sol';
    const input = {
        language: 'Solidity',
        sources: { [fileName]: { content: job.source_code } },
        settings: { outputSelection: { '*': { '': ['ast'] } } },
    };

    try {
        const output = JSON.parse(solc.compile(JSON.stringify(input)));

        if (output.errors) {
            const compilationErrors = output.errors.filter((e: any) => e.severity === 'error');
            if (compilationErrors.length > 0) {
                throw new Error(compilationErrors.map((e: any) => e.formattedMessage).join('\n'));
            }
        }
        
        const ast = output.sources[fileName].ast;
        if (!ast) { throw new Error("AST was not generated by the compiler."); }

        let usesUpgradeableContracts = false;
        let receiveFunctionNode: any | null = null;
        let callsOwnerOnlyFunctionInReceive = false;

        visit(ast, {
            // V1 Check: Detect if it's an upgradeable contract
            InheritanceSpecifier: (node) => {
                if (node.baseName.name && node.baseName.name.includes("Upgradeable")) {
                    usesUpgradeableContracts = true;
                }
            },
            FunctionDefinition: (node) => {
                // V2/V3: Find the AWM-style receive function
                if (node.name === 'receive' && node.parameters.parameters.length === 1 && node.parameters.parameters[0].typeName.name === 'bytes') {
                    receiveFunctionNode = node;
                    
                    // --- THE DEFINITIVE FIX IS HERE ---
                    // Now that we have the receive function, traverse *only its body*
                    // to see if it calls a privileged function.
                    visit(node.body, {
                        FunctionCall: (callNode) => {
                            if (callNode.expression.nodeType === 'Identifier' && (callNode.expression.name === '_transferOwnership' || callNode.expression.name === '_setOwner')) {
                                callsOwnerOnlyFunctionInReceive = true;
                            }
                        }
                    });
                    // --- END OF FIX ---
                }
            },
        });

        // --- V3: AWM Governance Exploit Risk Check ---
        // This check runs once after scanning the whole AST.
        if (receiveFunctionNode && callsOwnerOnlyFunctionInReceive) {
            const receiveFunctionBody = JSON.stringify(receiveFunctionNode.body);
            
            issues.push({
                issue_type: "Cross-Chain Governance Pattern Detected",
                description: "This contract appears to be a cross-chain governor, executing privileged actions based on incoming AWM messages.",
                recommendation: "Ensure this contract is properly secured. See specific checks below.",
            });

            if (!receiveFunctionBody.includes('sourceChainId')) {
                issues.push({
                    issue_type: "Critical AWM Governance Vulnerability",
                    description: "The AWM `receive` function calls an owner-only function but does not validate `warpMessage.sourceChainId`.",
                    recommendation: "This is a critical vulnerability. An attacker could send a message from their own malicious Subnet and take control. ALWAYS `require(warpMessage.sourceChainId == GOVERNANCE_CHAIN_ID)`.",
                });
            }
            if (!receiveFunctionBody.includes('sender')) {
                issues.push({
                    issue_type: "Critical AWM Governance Vulnerability",
                    description: "The AWM `receive` function calls an owner-only function but does not validate `warpMessage.sender`.",
                    recommendation: "This is a critical vulnerability. An attacker could deploy a contract on the governance chain and send a malicious message. ALWAYS `require(warpMessage.sender == GOVERNANCE_ADDRESS)`.",
                });
            }
        }
        // --- End of V3 ---
        
        console.log(`V3 analysis complete. Found ${issues.length} upgradeability issues for Job ID: ${job.job_id}`);

        const uniqueIssues = issues.filter((issue, index, self) => index === self.findIndex((t) => (t.description === issue.description)));
        return { job_id: job.job_id, worker_name: "UpgradeabilityWorkerV3", output: uniqueIssues };

    } catch (error: any) {
        return { job_id: job.job_id, worker_name: "UpgradeabilityWorkerV3", output: [{ issue_type: "Analysis Error", description: error.message || "The contract could not be analyzed." }]};
    }
}

async function publishResult(client: any, result: AnalysisResult) {
    const channel = 'sentinel_results';
    const resultJson = JSON.stringify(result);
    await client.rPush(channel, resultJson);
    console.log(`Published V3 result for Job ID: ${result.job_id}`);
}
main().catch(console.error);
