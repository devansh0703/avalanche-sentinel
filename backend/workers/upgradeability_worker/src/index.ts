import { createClient } from 'redis';
import solc from 'solc';

// --- Type Definitions (Unchanged) ---
interface AnalysisJob {
    job_id: string;
    source_code: string;
}
interface UpgradeIssue {
    issue_type: string;
    description: string;
    recommendation: string;
}
interface AnalysisResult {
    job_id: string;
    worker_name: string;
    output: UpgradeIssue[];
}

// --- Robust AST Visitor (Unchanged) ---
function visit(node: any, visitor: { [nodeType: string]: (node: any) => void }) {
    if (!node || typeof node !== 'object') return;
    if (node.nodeType && visitor[node.nodeType]) visitor[node.nodeType](node);
    for (const key in node) {
        if (node.hasOwnProperty(key)) {
            const child = node[key];
            if (child instanceof Array) {
                for (const item of child) visit(item, visitor);
            } else if (child) {
                visit(child, visitor);
            }
        }
    }
}

// --- Main Worker Logic (Unchanged) ---
async function main() {
    console.log('Starting Upgradeability & Governance Worker [V2 DEFINITIVE]...');
    const redisClient = createClient();
    await redisClient.connect();
    console.log('Successfully connected to Redis.');

    const channel = 'upgradeability_jobs';
    console.log(`Listening for jobs on channel: '${channel}'`);

    while (true) {
        try {
            const jobData = await redisClient.blPop(channel, 0);
            if (jobData) {
                console.log('\nReceived new job.');
                const job: AnalysisJob = JSON.parse(jobData.element);
                console.log(`Processing Job ID: ${job.job_id}`);
                const result = analyzeUpgradeabilityV2(job);
                await publishResult(redisClient, result);
            }
        } catch (error) {
            console.error('Error processing job:', error);
        }
    }
}

// --- V2: Definitive, Corrected Analysis Function ---
function analyzeUpgradeabilityV2(job: AnalysisJob): AnalysisResult {
    let issues: UpgradeIssue[] = [];
    const fileName = 'contract.sol';
    const input = {
        language: 'Solidity',
        sources: { [fileName]: { content: job.source_code } },
        settings: { outputSelection: { '*': { '': ['ast'] } } },
    };

    try {
        const output = JSON.parse(solc.compile(JSON.stringify(input)));

        if (output.errors) {
            const compilationErrors = output.errors.filter((e: any) => e.severity === 'error');
            if (compilationErrors.length > 0) {
                throw new Error(compilationErrors.map((e: any) => e.formattedMessage).join('\n'));
            }
        }
        
        const ast = output.sources[fileName].ast;
        if (!ast) { throw new Error("AST was not generated by the compiler."); }

        let usesUpgradeableContracts = false;
        
        visit(ast, {
            ContractDefinition: (node) => {
                let parentContracts: string[] = [];
                let ownVariables: string[] = [];
                let hasUpgradeableParent = false;
                
                // V1/V2 Check: Inheritance and Storage Layout Collision
                if (node.baseContracts && node.baseContracts.length > 0) {
                    for(const base of node.baseContracts) {
                        // --- THE DEFINITIVE FIX IS HERE ---
                        // Based on our previous debugging, the correct path is `baseName.name`.
                        const parentName = base.baseName.name;
                        // --- END OF FIX ---
                        parentContracts.push(parentName);
                        if (parentName && parentName.includes("Upgradeable")) {
                            hasUpgradeableParent = true;
                            usesUpgradeableContracts = true; // Set the global flag
                        }
                    }
                }

                if (node.nodes) {
                    for(const subNode of node.nodes) {
                        if (subNode.nodeType === 'VariableDeclaration' && subNode.stateVariable) {
                            ownVariables.push(subNode.name);
                        }
                    }
                }
                
                if (hasUpgradeableParent && ownVariables.length > 0) {
                    issues.push({
                        issue_type: "Potential Storage Collision",
                        description: `Contract '${node.name}' inherits from an upgradeable contract and also declares its own state variables (${ownVariables.join(', ')}).`,
                        recommendation: "When inheriting, new state variables must be declared AFTER all parent contract variables. Incorrect ordering can lead to storage collisions and data corruption during upgrades. Carefully review storage layouts.",
                    });
                }
            },
            FunctionDefinition: (node) => {
                // V2 Check: Unprotected Initializer
                if (node.name === 'initialize') {
                    let hasInitializerModifier = false;
                    if (node.modifiers) {
                        for (const modifier of node.modifiers) {
                            if (modifier.modifierName.name === 'initializer') {
                                hasInitializerModifier = true;
                                break;
                            }
                        }
                    }
                    if (!hasInitializerModifier) {
                         issues.push({
                            issue_type: "Unprotected Initializer",
                            description: "An `initialize` function was found without an `initializer` modifier.",
                            recommendation: "Proxy implementation contracts must protect their `initialize` function (e.g., with OpenZeppelin's `initializer` modifier) to prevent it from being called multiple times or by an attacker.",
                        });
                    }
                }
            },
            FunctionCall: (node) => {
                // V1 Check: EOA Ownership
                if (node.expression.nodeType === 'Identifier' && (node.expression.name === '_transferOwnership' || node.expression.name === '_setOwner')) {
                    if (node.arguments.length > 0 && node.arguments[0].nodeType === 'MemberAccess' && node.arguments[0].memberName === 'sender') {
                        // We will add this issue specifically if we know it's an upgradeable contract
                        if(usesUpgradeableContracts) {
                            issues.push({
                                issue_type: "High Risk for Multi-Chain",
                                description: "Ownership of the upgradeable contract appears to be set to `msg.sender`.",
                                recommendation: "For multi-chain deployments on Avalanche, setting ownership to a single EOA is a risk. Consider using a multi-sig or a DAO as the owner for better security.",
                            });
                        }
                    }
                }
                
                // V2 Check: `selfdestruct` in Implementation
                if(node.expression.nodeType === 'Identifier' && node.expression.name === 'selfdestruct') {
                    if (usesUpgradeableContracts) {
                        issues.push({
                            issue_type: "Critical Vulnerability: `selfdestruct`",
                            description: "A call to `selfdestruct` was found within the contract.",
                            recommendation: "Implementation contracts for proxies must NEVER contain `selfdestruct`. An attacker could call it on the implementation, destroying its code and rendering all proxies that point to it useless.",
                        });
                    }
                }
            },
        });
        
        console.log(`V2 analysis complete. Found ${issues.length} upgradeability issues for Job ID: ${job.job_id}`);

    } catch (error: any) {
        issues.push({
            issue_type: "Analysis Error",
            description: error.message || "The contract could not be analyzed."
        });
    }

    // Filter out duplicate issues before returning
    const uniqueIssues = issues.filter((issue, index, self) =>
        index === self.findIndex((t) => (
            t.issue_type === issue.issue_type && t.description === issue.description
        ))
    );

    return {
        job_id: job.job_id,
        worker_name: "UpgradeabilityWorkerV2",
        output: uniqueIssues,
    };
}

async function publishResult(client: any, result: AnalysisResult) {
    const channel = 'sentinel_results';
    const resultJson = JSON.stringify(result);
    await client.rPush(channel, resultJson);
    console.log(`Published V2 result for Job ID: ${result.job_id}`);
}
main().catch(console.error);
