import { createClient } from 'redis';
import solc from 'solc';

// --- Interfaces (Unchanged) ---
interface AnalysisJob {
    job_id: string;
    source_code: string;
}
interface UpgradeIssue {
    issue_type: string;
    description: string;
    recommendation: string;
}
interface AnalysisResult {
    job_id: string;
    worker_name: string;
    output: UpgradeIssue[];
}

// --- Robust AST Visitor (Unchanged) ---
function visit(node: any, visitor: { [nodeType: string]: (node: any) => void }) {
    if (!node || typeof node !== 'object') return;
    if (node.nodeType && visitor[node.nodeType]) visitor[node.nodeType](node);
    for (const key in node) {
        if (node.hasOwnProperty(key)) {
            const child = node[key];
            if (child instanceof Array) {
                for (const item of child) visit(item, visitor);
            } else if (child) {
                visit(child, visitor);
            }
        }
    }
}

// --- Main Server Logic (Unchanged) ---
async function main() {
    console.log('Starting Upgradeability & Governance Worker [FINAL VERSION]...');
    const redisClient = createClient();
    await redisClient.connect();
    console.log('Successfully connected to Redis.');
    const channel = 'upgradeability_jobs';
    console.log(`Listening for jobs on channel: '${channel}'`);
    while (true) {
        try {
            const jobData = await redisClient.blPop(channel, 0);
            if (jobData) {
                console.log('\nReceived new job.');
                const job: AnalysisJob = JSON.parse(jobData.element);
                console.log(`Processing Job ID: ${job.job_id}`);
                const result = analyzeUpgradeability(job);
                await publishResult(redisClient, result);
            }
        } catch (error) {
            console.error('Error processing job:', error);
        }
    }
}

// --- FINAL, CORRECTED ANALYSIS FUNCTION ---
function analyzeUpgradeability(job: AnalysisJob): AnalysisResult {
    let issues: UpgradeIssue[] = [];
    const fileName = 'contract.sol';
    const input = {
        language: 'Solidity',
        sources: { [fileName]: { content: job.source_code } },
        settings: { outputSelection: { '*': { '': ['ast'] } } },
    };

    try {
        const output = JSON.parse(solc.compile(JSON.stringify(input)));

        if (output.errors) {
            const compilationErrors = output.errors.filter((e: any) => e.severity === 'error');
            if (compilationErrors.length > 0) {
                throw new Error(compilationErrors.map((e: any) => e.formattedMessage).join('\n'));
            }
        }
        
        const ast = output.sources[fileName].ast;
        if (!ast) {
             throw new Error("AST was not generated by the compiler.");
        }

        let usesUpgradeableContracts = false;
        let ownerIsEOA = false;

        visit(ast, {
            InheritanceSpecifier: (node) => {
                // THE FINAL FIX: Based on your debug output, this is the correct path.
                if (node.baseName && node.baseName.name && node.baseName.name.includes("Upgradeable")) {
                    usesUpgradeableContracts = true;
                }
            },
            FunctionCall: (node) => {
                // This logic remains the same and is correct for the solc AST.
                if (node.expression.nodeType === 'Identifier' && (node.expression.name === '_transferOwnership' || node.expression.name === '_setOwner')) {
                    if (node.arguments.length > 0 && node.arguments[0].nodeType === 'MemberAccess' && node.arguments[0].memberName === 'sender') {
                        ownerIsEOA = true;
                    }
                }
            }
        });

        if (usesUpgradeableContracts) {
            issues.push({
                issue_type: "Informational",
                description: "Contract appears to use an upgradeable proxy pattern (e.g., UUPS).",
                recommendation: "Ensure proxy and implementation contracts are deployed and initialized correctly.",
            });
            
            if (ownerIsEOA) {
                issues.push({
                    issue_type: "High Risk for Multi-Chain",
                    description: "Ownership of the upgradeable contract appears to be set to `msg.sender` in an initializer or constructor.",
                    recommendation: "For multi-chain deployments on Avalanche, setting ownership to a single EOA is a significant risk. Consider using a multi-sig wallet (like Gnosis Safe) or a DAO contract as the owner to improve security and operational resilience.",
                });
            }
        }
        console.log(`Analysis complete. Found ${issues.length} upgradeability issues for Job ID: ${job.job_id}`);

    } catch (error: any) {
        issues.push({
            issue_type: "Analysis Error",
            description: error.message || "The contract could not be analyzed.",
            recommendation: "Ensure the contract is compilable and uses standard patterns.",
        });
    }

    return {
        job_id: job.job_id,
        worker_name: "UpgradeabilityWorker",
        output: issues,
    };
}

async function publishResult(client: any, result: AnalysisResult) {
    const channel = 'sentinel_results';
    const resultJson = JSON.stringify(result);
    await client.rPush(channel, resultJson);
    console.log(`Published result for Job ID: ${result.job_id}`);
}

main().catch(console.error);
